<!doctype html>
<html>
  <head>
    <title>Model Cache Test</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }
      .log {
        background: #f5f5f5;
        padding: 10px;
        margin: 10px 0;
        border-radius: 4px;
      }
      .error {
        background: #ffebee;
        color: #c62828;
      }
      .success {
        background: #e8f5e9;
        color: #2e7d32;
      }
      button {
        padding: 10px 20px;
        margin: 5px;
      }
    </style>
  </head>
  <body>
    <h1>Model Cache Test</h1>
    <p>This page tests the new model caching functionality.</p>

    <button onclick="testCache()">Test Cache</button>
    <button onclick="clearCache()">Clear Cache</button>
    <button onclick="checkCacheSize()">Check Cache Size</button>
    <button onclick="cleanupExpiredCache()">Cleanup Expired</button>
    <button onclick="getCacheStatistics()">Get Cache Stats</button>

    <div id="logs"></div>

    <script>
      const CACHE_NAME = 'onnx-model-cache-v1';
      const MODEL_URL =
        'https://huggingface.co/Xenova/multilingual-e5-small/resolve/main/onnx/model_quantized.onnx';

      function log(message, type = 'info') {
        const logs = document.getElementById('logs');
        const div = document.createElement('div');
        div.className = `log ${type}`;
        div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logs.appendChild(div);
        console.log(message);
      }

      async function getCachedModelData(modelUrl) {
        const cache = await caches.open(CACHE_NAME);

        // Check cache
        const cachedResponse = await cache.match(modelUrl);

        if (cachedResponse) {
          log('Model found in cache. Loading from there.', 'success');
          return cachedResponse.arrayBuffer();
        }

        log('Model not found in cache. Fetching from network...');

        try {
          const response = await fetch(modelUrl);

          if (!response.ok) {
            throw new Error(`Failed to fetch model: ${response.status} ${response.statusText}`);
          }

          // Store in cache
          await cache.put(modelUrl, response.clone());
          log('Model fetched from network and successfully cached.', 'success');

          return response.arrayBuffer();
        } catch (error) {
          log(`Error fetching or caching model: ${error.message}`, 'error');
          await cache.delete(modelUrl);
          throw error;
        }
      }

      async function testCache() {
        try {
          log('Starting cache test...');
          const startTime = performance.now();

          const modelData = await getCachedModelData(MODEL_URL);

          const endTime = performance.now();
          const duration = (endTime - startTime).toFixed(2);

          log(`Cache test completed in ${duration}ms`, 'success');
          log(`Model data size: ${(modelData.byteLength / 1024 / 1024).toFixed(2)} MB`, 'success');
        } catch (error) {
          log(`Cache test failed: ${error.message}`, 'error');
        }
      }

      async function clearCache() {
        try {
          const cache = await caches.open(CACHE_NAME);
          await cache.delete(MODEL_URL);
          log('Cache cleared successfully', 'success');
        } catch (error) {
          log(`Failed to clear cache: ${error.message}`, 'error');
        }
      }

      async function checkCacheSize() {
        try {
          const cache = await caches.open(CACHE_NAME);
          const keys = await cache.keys();
          log(`Cache contains ${keys.length} entries`, 'success');

          for (const request of keys) {
            if (request.url.startsWith('metadata:')) continue;

            const response = await cache.match(request);
            if (response) {
              const blob = await response.blob();
              log(`- ${request.url}: ${(blob.size / 1024 / 1024).toFixed(2)} MB`);
            }
          }
        } catch (error) {
          log(`Failed to check cache size: ${error.message}`, 'error');
        }
      }

      async function cleanupExpiredCache() {
        try {
          log('Starting expired cache cleanup...');

          // This would normally import from the module, but for testing we'll simulate
          const cache = await caches.open(CACHE_NAME);
          const keys = await cache.keys();
          let cleanedCount = 0;

          for (const request of keys) {
            if (request.url.startsWith('metadata:')) {
              try {
                const response = await cache.match(request);
                if (response) {
                  const metadata = await response.json();
                  const now = Date.now();
                  const expiryTime = metadata.timestamp + 7 * 24 * 60 * 60 * 1000; // 7 days

                  if (now > expiryTime) {
                    await cache.delete(request);
                    await cache.delete(metadata.modelUrl);
                    cleanedCount++;
                    log(`Cleaned expired entry: ${metadata.modelUrl}`);
                  }
                }
              } catch (error) {
                await cache.delete(request);
                cleanedCount++;
              }
            }
          }

          log(`Cleanup complete. Removed ${cleanedCount} expired entries.`, 'success');
        } catch (error) {
          log(`Failed to cleanup expired cache: ${error.message}`, 'error');
        }
      }

      async function getCacheStatistics() {
        try {
          log('Getting cache statistics...');

          const cache = await caches.open(CACHE_NAME);
          const keys = await cache.keys();
          let totalSize = 0;
          let entryCount = 0;
          const entries = [];

          for (const request of keys) {
            if (request.url.startsWith('metadata:')) continue;

            const response = await cache.match(request);
            if (response) {
              const blob = await response.blob();
              totalSize += blob.size;
              entryCount++;

              // Try to get metadata
              const metadataKey = `metadata:${request.url}`;
              const metadataResponse = await cache.match(metadataKey);
              let age = 'unknown';
              let expired = false;

              if (metadataResponse) {
                try {
                  const metadata = await metadataResponse.json();
                  const daysDiff = Math.round(
                    (Date.now() - metadata.timestamp) / (1000 * 60 * 60 * 24),
                  );
                  age = `${daysDiff} days`;
                  expired = daysDiff > 7;
                } catch (error) {
                  expired = true;
                }
              } else {
                expired = true;
              }

              entries.push({
                url: request.url,
                size: blob.size,
                sizeMB: (blob.size / 1024 / 1024).toFixed(2),
                age,
                expired,
              });
            }
          }

          log(`Total cache size: ${(totalSize / 1024 / 1024).toFixed(2)} MB`, 'success');
          log(`Total entries: ${entryCount}`, 'success');

          entries.forEach((entry) => {
            const status = entry.expired ? ' (EXPIRED)' : '';
            log(`- ${entry.url.split('/').pop()}: ${entry.sizeMB} MB, ${entry.age}${status}`);
          });
        } catch (error) {
          log(`Failed to get cache statistics: ${error.message}`, 'error');
        }
      }

      log('Cache test page loaded. Click buttons to test cache functionality.');
    </script>
  </body>
</html>
